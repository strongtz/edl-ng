using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace QCEDL.Analyzer;

[Generator]
public sealed class EnumToStringFastGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var enumDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is EnumDeclarationSyntax,
                transform: static (ctx, _) => (EnumDecl: (EnumDeclarationSyntax)ctx.Node,
                                               Model: ctx.SemanticModel))
            .Where(static t => t.Model.GetDeclaredSymbol(t.EnumDecl, CancellationToken.None) is not null);

        var allEnums = enumDeclarations.Collect();

        context.RegisterSourceOutput(allEnums, (spc, enums) =>
        {
            foreach (var (enumDecl, model) in enums)
            {
                var enumSymbol = (INamedTypeSymbol)model.GetDeclaredSymbol(enumDecl)!;
                GenerateExtensionForEnum(enumSymbol, spc);
            }
        });
    }

    private static void GenerateExtensionForEnum(INamedTypeSymbol enumSymbol, SourceProductionContext spc)
    {
        var enumName = enumSymbol.Name;
        var @namespace = enumSymbol.ContainingNamespace.IsGlobalNamespace
            ? null
            : enumSymbol.ContainingNamespace.ToDisplayString();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("using System;");
        if (!string.IsNullOrEmpty(@namespace))
        {
            sb.AppendLine($"namespace {@namespace}");
            sb.AppendLine("{");
            sb.AppendLine("    internal static class " + enumName + "Extensions");
            sb.AppendLine("    {");
            sb.AppendLine($"        internal static string ToStringFast(this {enumName} value)");
            sb.AppendLine("        {");
            sb.AppendLine("            switch (value)");
            sb.AppendLine("            {");
        }
        else
        {
            sb.AppendLine("internal static class " + enumName + "Extensions");
            sb.AppendLine("{");
            sb.AppendLine($"    internal static string ToStringFast(this {enumName} value)");
            sb.AppendLine("    {");
            sb.AppendLine("        switch (value)");
            sb.AppendLine("        {");
        }

        foreach (var member in enumSymbol.GetMembers().OfType<IFieldSymbol>().Where(f => f.ConstantValue is not null))
        {
            var memberName = member.Name;
            var mapped = member
                .GetAttributes()
                .FirstOrDefault(attr => attr.AttributeClass?.Name == "XmlEnumAttribute" ||
                                        attr.AttributeClass?.ToDisplayString() == "XmlAttribute")
                ?.NamedArguments
                .FirstOrDefault(kv => kv.Key == "Name")
                .Value.Value as string;

            var literal = mapped is null
                ? memberName
                : mapped.Replace("\\", "\\\\").Replace("\"", "\\\"");
            sb.AppendLine($"                case {enumName}.{memberName}: return \"{literal}\";");
        }

        sb.AppendLine("                default: return value.ToString();");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        if (!string.IsNullOrEmpty(@namespace))
        {
            sb.AppendLine("    }");
        }

        sb.AppendLine("}");

        var hintName = $"{enumSymbol.Name}_ToStringFast.g.cs";
        spc.AddSource(hintName, SourceText.From(sb.ToString(), Encoding.UTF8));
    }
}
